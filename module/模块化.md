# 模块化

## 模块
模块是关于项目内代码组织的。扮演着 Rust 命名空间的角色，是构成 Rust 程序或库的函数、类型、常量等的容器。
模块是一组语法项的集合，这些语法项具有命名的特性。需要使用 mod 关键词，默认为私有的。
可以使用 pub 关键字使某个语法项声明为公共的。

```rust
mod spores {
    use cells::{Cell, Gene};
    pub struct Spore {
       // ...
    }

    pub fn produce_spore(factory: &mut Sporanium) -> Spore {
        // ...
    }

    pub(crate) fn genes(spore: &Spore) -> Vec<Gene> {
        // ...
    }

    fn recombine(parent: &mut Cell) {
        // ...
    }
}

```
pub(crate) 表示在这个 crate 中的任何地方都能使用，但不会作为外部接口的一部分公开，不会被其他 crate 使用。 
未标记为 pub 的内容都是私有的，只能在定义它的模块及其任意子模块中使用。

## 单独文件中的模块
模块还可以这样写：
```rust
mod spores;

```
然后将 spores 模块的主体代码，也就是花括号里的，保存到一个单独的名为 spores.rs 的文件中。
模块可以有自己的目录。当 Rust 看到 mod spores; 时，会同时检查 spores.rs 和 spores/mod.rs，如果这两个文件都存在或都不存在，就会报错。如果 spores 模块还有子模块，那么考虑使用 spores/mod.rs 的方式。

```
fern_sim/
├── Cargo.toml
└── src/
    ├── main.rs
    ├── spores.rs
    └── plant_structures/
        ├── mod.rs
        ├── leaves.rs
        ├── roots.rs
        └── stems.rs”

```

## 路径与导入

:: 运算符用于访问模块中的各项特性。项目中任何位置的代码都可通过写出其路径来引用：

```rust
if s1 > s2 {
	std::mem::swap(&mut s1, &mut s2);
}

```

或者使用 use 将这些特性导入到当前模块中：

```rust
use std::mem;
if s1 > s2 {
	mem::swap(&mut s1, &mut s2);
}


use std::collections::{HashMap, HashSet}; // 按需导入
use std::fs::{self, File};
use std::io::prelude::*; // 导入所有语法项目
use std::io::Result as IOResult; // 重命名

```

模块不能自动访问其父模块的内容。例如 proteins 模块的 proteins/mod.rs文件有如下代码：

```rust
// proteins/mod.rs
pub enum AminoAcid { ... }
pub mod synthesis;

```

那么 synthesis 子模块中不能直接使用 AminoAcid 类型。需要使用 super 显式导入。
默认情况下，路径是相对于当前模块的。self 也是当前模块的同义词。
关键字 super 和 crate 在路径中有着特殊的含义：super 指父模块，crate 指当前模块所在的 crate。使用 crate 根路径而不是当前模块的路径可以更容易地在项目中移动代码，因为如果当前模块的路径发生了变化，不会破坏任何导入。
子模块可使用 use super::* 访问父模块中的私有语法项。
Rust 中有一种特殊路径，称为绝对路径，该路径以 :: 开头。

## 公开结构体字段

结构体声明为 pub 时，其字段还是私有的。要暴露其字段的话，其字段也需要声明为 pub。

```rust
pub struct Fern {
	pub roots: RootSet,
	pub stems: StemSet
}

```

https://juejin.cn/post/7361973121790459954