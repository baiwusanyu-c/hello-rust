# 错误处理

错误在程序开发中是不可避免的。Rust 将错误分为两大类：可恢复的和不可恢复的。 
发生不可恢复的错误，例如数组越界，程序会 panic。
同时，Rust 提供了 Result<T, E> 类型来处理可恢复的错误，例如文件读取错误。

## 不可恢复 panic
用来处理永远不应该发生的错误。例如：

数组越界访问；
整数除以 0；
在恰好为 Err 的 Result 上调用 .expect();
断言失败。

当代码检测到出现错误需要立即触发 panic 时，可以使用 panic!() 宏。
Rust 在发生 panic 时可以展开调用栈（默认），也可中止进程。

### 展开调用栈

```rust
fn main() {
    println!("{}", 100/0);
}

```

在 Rust 中触发了 panic，通常会按如下方式处理：

打印一条错误信息到终端。
展开调用栈；
最后，线程退出。如果 panic 是主线程，退出整个进程。

panic 是基于线程的。一个线程 panic，其他线程可以继续做自己的事。
还有一种方式可以捕获调用栈展开，让线程存活并继续运行。std::panic::catch_unwind() 可以做到这一点。这是 Rust 的测试工具用于在测试中断言失败时进行恢复的机制。

### 中止

展开调用栈事默认的 panic 行为，但是，在两种情况下 Rust 不会试图展开调用栈。
Rust 在试图处理第一个 panic 时，.drop() 方法触发了第二个 panic，那么这个 panic 就是致命的。Rust 会停止展开调用栈并中止整个进程。
此外，Rust 处理 panic 的行为是可定制的。如果使用 -C panic=abort 参数进行编译，那么程序中的第一个 panic 会立即中止进程。

## 可恢复的错误 Result

Rust 中没有异常。函数执行失败时候会返回 Result 类型。它会指示出可能的失败。要么返回一个成功的结果，要么返回一个错误的结果。
当函数返回一个 Result 类型值，即可获得以下方法：

* result.is_ok() 已成功
* result.is_err() 已出错
* result.ok() 成功值
* result.err() 错误值
* result.unwarp_or(fallback) 如果 result 为成功结果，就返回成功值；否则，返回 fallback，丢弃错误值。
* result.unwarp_or_else(fallbakc_fn) 解包，否则调用
* result.unwarp() 解包。如果 result 错误，发生 panic。
* result.expect(message) 与 unwarp() 相同，但是可以提供在 panic 时的消息。
* result.as_ref() 转引用，将 Result<T, E> 转为 Result<&T, &E>。
* result.as_mut() 转可变引用。

## 打印错误

标准库中定义了几种错误类型。

* std::io::Error;
* std::fmt::Error;
* std:::str::Utf8Error

它们都实现了 std::error::Error 特型，意味着它们都有以下特性和方法：

* 可通过 println!() 进行打印。使用格式说明符 {} 打印简短错误信息。或使用 {:?} 获取该错误的 Debug 视图。
* err.to_string() 转字符串，以 String 形式返回错误信息。
* err.source() 错误来源。

## 传播错误

希望错误暂时不处理，而是沿着调用栈向上传播。使用 ? 运算符可执行此操作。

```rust
let weather = get_weather(hometown)?;

```
* 如果结果成功，会解包 Result 以获取其中的成功值。
* 如果错误，会立即从函数返回，将错误结果沿着调用链向上传播。


## 为什么优先选择 Result？

为什么 Rust 会优先选择 Result 而非直接触发 panic。

* Rust 要求程序员在每个可能发生错误的地方做决策，并将其记录在代码中。
* 最常见的决策是让错误继续传播，使用 ? 实现。
* 是否可能出错是每个函数返回类型的一部分。
* Rust 会检查 Result 值是否被用过，这样就不会意外地让错误悄悄溜过去。
* Result 是一种数据类型，将成功结果和错误结果存储在同一个集合中。