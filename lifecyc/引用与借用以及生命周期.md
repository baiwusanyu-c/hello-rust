# 引用与借用以及生命周期

## 引用与借用

* 引用：一种非拥有型的指针，它是一个地址，可以访问该地址指向的数据。
* 借用: Rust 把创建对某个值的引用的操作称为借用。

### 如何使用引用

**引用的一个非常典型的用途：允许函数在不获取所有权的情况下访问或操纵某个结构。**
在 Rust 中，共享引用是通过 & 运算符显式创建的，同时要用 * 运算符显式解引用。

```rust
let x = 10;
let r = &x;
assert!(*r == 10);
```
`&mut` 创建可变引用。 引用的规则：

* 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
* 引用必须总是有效的。

```rust
fn main() {
    // 引用
    let s1 = String::from("Hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
    //  The length of 'Hello' is 5.
}

fn calculate_length(s: &String) -> usize {
    s.len() // (*s).len()
}

```

### 对引用变量赋值

````rust
let x = 10;
let y = 20;
let mut r = &x;

if b { r = &y; }
````

r 最初指向 x。 如果 b 为 true，则代码会把它改为指向 y。

### 对引用进行引用

Rust 允许对引用进行引用。

```rust
struct Point { x: i32, y: i32 }
let point = Point { x: 1000, y: 729 };
let r: &Point = &point;
let rr: &&Point = &r;
let rrr: &&&Point = &rr;
```

### 比较引用

Rust 的比较运算符也能"看穿"任意数量的引用。

```rust
let x = 10;
let y = 10;
let rx = &x;
let ry = &y;
let rrx = &rx;
let rry = &ry;
assert!(rrx <= rry);
assert!(rrx == rry);
```

如果真想知道两个引用是否指向同一块内存，可以使用 `std::ptr::eq`

## 生命周期

引用看起来像 C 或 C++ 中的普通指针，但普通指针是不安全的，
Rust 如何保持对引用的全面控制呢？ Rust 中每个引用都有其生命周期， 也就是确保引用有效的作用域。 
**一旦函数和类型中有了引用，就需要考虑生命周期的问题。**

### 生命周期避免了悬垂引用

> 悬垂引用：指向了不存在或已经被释放的内存的引用。

```rust
// 生命周期
{
    let r;
    {
        let x = 1;
        r = &x;
    } // x 被释放，此时 r 引用了一个不存在内存块
    assert_eq!(*r, 1);
}
```

### 将引用用作函数参数
在 Rust 中如果需要将引用作为参数传递，需要为参数指定生命周期。
```rust
static mut STASH: &i32 = &10;
fn f(p: &'static i32) {
    unsafe {
        STASH = p;
    }
}
```
Rust 中全局变量的等价物称为 静态变量 `(static)`。它在程序启动时就会被创建并一直存续到程序终止时。
它的生命周期是全局的，`'static` 静态生命周期。 也可定义任意生命周期参数。

```rust
fn f<'a>(p: &'a i32) { ... }
```

生命周期 'a 读作 “tick a”，是 f 的生命周期参数。<'a> 的意思是“对于任意生命周期 'a”。指向 p 的引用的生命周期是 'a，它可以是任何能涵盖对 f 调用的生命周期。

### 把引用传给函数

```rust
fn g<'a>(p: &'a &i32) { ... }
let x = 10;
g(&x);
```
看 g 的签名，Rust 就知道它不会将 p 保存在生命周期可能超出本次调用的任何地方：
包含本次调用的任何生命周期都必须符合 'a 的要求。所以，Rust 为 &x 选择了尽可能短的生命周期，
即调用 g 时候的生命周期。这满足了所有约束：它的生命周期不会超出 x，并且会涵盖对 g 的完整调用。所以这段代码通过了审核。

* 'static 静态生命周期
* 'a 函数生命周期参数

### 包含引用的结构体

如果结构体的字段中使用引用，必须写出它的生命周期。

```rust
struct S {
	r: &'static i32
}
```

上面的 r 只能引用生命周期贯穿整个程序的 i32 值。 另一种方法是给类型指定一个生命周期参数 'a

```rust
struct S<'a> {
	r: &'a i32
}
```

现在 S 类型有了一个生命周期，就像引用类型一样。
每创建一个 S 类型的值都会获得一个全新的生命周期 'a，它会受到该值的使用方式的限制。
存储在 r 中的任何引用的生命周期最好都涵盖 'a，并且 'a 必须比存储在 S 中的任何内容的生命周期都要长。

```rust
struct S<'a> {
	r: &'a i32
}
let s;
{
	let x = 10;
	s = S { r: &x };
}
assert_eq!(*s.r, 10); // 错误：从已被丢弃的 `x` 中读取

```

如果创建了一个 S 值，并将 &x 存储在 r 字段中，就会将 'a 完全限制在了 x 的生命周期内部。
s = S { r: &x }; 会将此 S 存储在一个变量中，该变量的生命周期会延续到实例的末尾，这种限制决定了 'a 比 s 的生命周期更长。
此时，就产生了矛盾。所以 Rust 拒绝执行代码。
如果将具有生命周期的类型放置到其他类型中，需要指定生命周期参数。

### 不同的生命周期参数

```rust
struct S<'a> {
	x: &'a i32,
	y: &'a i32
}
```

下面的代码会出现错误：

```rust
let x = 10;
let r;
{
    let y = 20;
    {
        let s = S { x: &x, y: &y };
        r = s.x;
    }
}
println!("{}", r);

```