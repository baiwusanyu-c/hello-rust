<table>
    <thead>
    <tr>
        <th>类型</th>
        <th>说明</th>
        <th>值</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>
            <code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>
        </td>
        <td>给定位宽的有符号整数和无符号整数</td>
        <td>
            <code>4</code>、<code>-5i8</code>、<code>0x400u16</code>、<code>0o100i16</code>、<code>20_922_789_888_000u64</code>、<code>b'*'</code>（u8
            字节字面量）
            u 开头无符号，正整型
            i 开头头符号，可正，可负整型
        </td>
    </tr>
    <tr>
        <td><code>isize</code>、<code>usize</code></td>
        <td>与机器字（32位或64位）一样大的有符号整数和无符号整数</td>
        <td></td>
    </tr>
    <tr>
        <td><code>f32</code>、<code>f64</code></td>
        <td>单精度 IEEE 浮点数、双精度 IEEE 浮点数</td>
        <td></td>
    </tr>
    <tr>
        <td><code>bool</code></td>
        <td>布尔值</td>
        <td><code>true</code>、<code>false</code></td>
    </tr>
    <tr>
        <td><code>char</code></td>
        <td>Unicode 字符，32 位宽（4字节）</td>
        <td><code>'x'</code> <code>'\\n'</code></td>
    </tr>
    <tr>
        <td><code>(char, i8, bool)</code></td>
        <td>元组，允许混合类型</td>
        <td></td>
    </tr>
    <tr>
        <td><code>()</code></td>
        <td>单元元组、空元组</td>
        <td></td>
    </tr>
    <tr>
        <td><code>struct S { x: f32, y: f32 }</code></td>
        <td>具名字段型结构体</td>
        <td></td>
    </tr>
    <tr>
        <td><code>struct T(i32, char)</code></td>
        <td>元组结构体</td>
        <td></td>
    </tr>
    <tr>
        <td><code>struct E;</code></td>
        <td>单元结构体</td>
        <td></td>
    </tr>
    <tr>
        <td><code>enum Attend { OnTime, Late(u32) }</code></td>
        <td>枚举</td>
        <td></td>
    </tr>
    <tr>
        <td><code>Box&lt;Attend&gt;</code></td>
        <td>Box：指向堆中值的拥有型指针</td>
        <td></td>
    </tr>
    <tr>
        <td><code>&amp;i32</code>、<code>&amp;mut i32</code></td>
        <td>共享引用和可变引用；非拥有型指针，其声明周期不能超出引用目标</td>
        <td></td>
    </tr>
    <tr>
        <td><code>String</code></td>
        <td>UTF-8 字符串，动态分配大小</td>
        <td></td>
    </tr>
    <tr>
        <td><code>&amp;str</code></td>
        <td>对 <code>str</code> 的引用：指向 UTF-8 文本的非拥有型指针</td>
        <td></td>
    </tr>
    <tr>
        <td><code>[f64; 8]</code></td>
        <td>数组，固定长度，其元素类型都相同</td>
        <td></td>
    </tr>
    <tr>
        <td><code>Vec&lt;f64&gt;</code></td>
        <td>向量，可变长度，其元素类型都相同</td>
        <td><code>vec![1, 2, 3, 4]</code></td>
    </tr>
    <tr>
        <td><code>&amp;[u8]</code>、<code>&amp;mut [u8]</code></td>
        <td>对切片（数组或向量的某一部分）的引用，包含指针和长度</td>
        <td><code>&amp;v[10..20]</code>、<code>&amp;mut a[..]</code></td>
    </tr>
    <tr>
        <td><code>Result&lt;u64, Error&gt;</code></td>
        <td>可能失败的操作结果：成功值 <code>Ok(v)</code>；失败值 <code>Err(e)</code></td>
        <td></td>
    </tr>
    <tr>
        <td><code>Option&lt;&amp;str&gt;</code></td>
        <td>可选值：没有值，取值为 <code>None</code>；有值，取值为 <code>Some(v)</code></td>
        <td></td>
    </tr>
    <tr>
        <td><code>&amp;dyn any</code>、<code>&amp;mut dyn Read</code></td>
        <td><strong>特型对象</strong>：对任何实现了一组给定方法的值的引用</td>
        <td><code>value as &amp;dyn Any</code>、<code>&amp;mut file as &amp;mut dyn Read</code></td>
    </tr>
    <tr>
        <td><code>fn(&amp;str) -&gt; bool</code></td>
        <td>函数指针</td>
        <td><code>str::is_empty</code></td>
    </tr>
    <tr>
        <td>（闭包没有显式的书写形式）</td>
        <td>闭包</td>
        <td><code>&amp;#124; a, b &amp;#124; a * a + b * b</code></td>
    </tr>
    </tbody>
</table>

https://juejin.cn/post/7359076801279328308

## 浮点类型
Rust 提供了 IEEE 单精度浮点类型（f32）和双精度浮点类型（f64）。默认选择 f64。
f32 类型和 f64 类型具有一些特殊值的关联常量：正无穷大（INFINITY）、负无穷大（NEG_INFINITY）、非数值（NAN）、最小有限值（MIN）、最大有限值（MAX）。
std::f32::consts 模块和 std::f64::consts 模块提供了各种常用的数学常量，比如 E、PI 和 2 的平方根。

## 字符 - char
字符是 char 类型，会以 32 位值（4字节）表示单个 Unicode 字符。使用单引号创建 char 字面量。

```rust
let letter: char = 'a';   // 英文字母
let number: char = '1';   // 数字字符
let symbol: char = '$';   // 符号
let space: char = ' ';    // 空格
let emoji: char = '😂';  // 表情符号
let chinese: char = '中'; // 中文字符

```

## 元组

元组是各种类型的值对，例如二元组、三元组等等。所以也叫做 n 元组。不同长度的元组类型不同。
元组的每个元素类型可不同。只允许通过常量下标来获取，例如元组 a，要获取第三个元素需要通过 a.2 获取。
元组通常用来从一个函数返回多个值。 例如，字符串切片的 split_at 方法将字符串分成两半，并返回一个元组。可以使用模式匹配的方法将返回值的每个元素赋值给不同的变量。
如果元组只有一个元素，那么必须在后面添加逗号，例如 (100, )。
```rust
// 元组
#[allow(unused_variables)]
fn main() {
    let temp = (); // 零元组
    let one = (100, );
    let two = (100, 200);
    println!("{}", two.0); // 100

    let text = "Hello World";
    // 元组解构
    let (hello, world) = text.split_at(5);
    println!("hello: {}, world: {}", hello, world); // hello: Hello, world:  World
}

```

## 指针类型

### 引用
* &T 不可变共享引用。只读。可以同时拥有多个给定值的共享引用。
* &mut T 可变的独占引用。可以读取和修改它指向的值。如果该引用存在，就不能对该值有任何其他类型的引用。

## 数组
数组的类型为 [T; N]，每个值都是 T 类型，数组的长度是 N。
数组是编译期确定的常量。数组的长度是类型的一部分。**数组不能追加新元素或缩小**。 
编写数组的方法：

```rust
let a: [i32; 3] = [1, 2, 3];
let b = ["a", "b", "c"];
a[0] // 1
a.len() // 3

```
数组本身没有提供诸如遍历、搜索、排序等方法，这些都是切片提供的方法

## 向量

Vec<T> 类型可称为 T 的向量。是一个动态分配且可增长的 T 类型的值序列。**向量的元素存在于堆中**，所以可以随意调整向量的大小。
向量有一下几个关键信息：

* 有一个指向堆上数组开始位置的指针；
* 向量的长度，即当前向量持有的元素数量；
* 向量的容量，即堆上分配的内存能容纳的元素数量。

当堆上的缓冲区达到其最大容量时，往向量中添加另一个元素需要分配一个更大的缓冲区，将当前内容复制到其中，更新向量的指针和容量以指向新缓冲区，最后释放旧缓冲区。
创建向量方式很多。最简单使用 vec! 宏来创建向量。

```rust
let v = vec![2, 3, 5, 7];
v.push(8); // 添加元素

let repeat_v = vec![0; 4] // [0, 0, 0, 0]  

let vec_v = Vec::new(); // 创建空向量。
vec_v.push('a');

// 从迭代器生成的值构建一个向量
let v: Vec<i32> = (0..5).collect(); // 使用 collect 时候，通常要指定类型

```

## 切片

切片（[T]），是数组或向量中的一个区域。 类型 &[T] 和 &mut [T] 可称为 T 的**共享切片** 和 T 的**可变切片**。
切片是对数组或向量的一部分值的引用。 
对切片的引用是一个**胖指针：一个双字值，包括指向切片第一个元素的指针和切片中元素的数量。**

```rust
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
let a: [f64; 4] = [0.0, -0.707, -1.0, -0.707];

let sv: &[f64] = &v;
let sa: &[f64] = &a;

```
普通引用是指向单个值的**非拥有型指针**。
对切片的引用是指向内存中一系列连续值的**非拥有型指针**。 如果要对数组或向量进行操作，使用切片是不错的选择。

## String

在 Rust 中，String 类型是一个标准库提供的动态、可增长、可变的、拥有所有权的 UTF-8 编码的字符串类型。
它是用来存储和操作可变长的文本数据的。 
String 类似 Vec<T>。
它会在堆上分配自己的缓冲区。 String 创建的几个方法：

* .to_string() 将 &str 转换为 String。会进行复制。
* format!() 宏会返回一个新的 String。
* 字符串的数组、切片和向量都有 concat() 和 join() 方法，能从多个字符串中形成一个新的 String。
```rust
let mut s = String::new(); // 空的 String
let hello = String::from("Hello, world!"); // 从字符串字面量创建 String

let mut s = String::from("foo");
s.push_str("bar"); // 追加字符串切片
s.push('!'); // 追加单个字符
println!("{}", s); // 输出："foobar!"

let s = String::from("example");
let slice: &str = &s; // 借用 String 为 &str

let slice = "example";
let s = slice.to_string(); // 或 String::from(slice)

```