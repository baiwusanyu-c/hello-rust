# 特型与泛型

https://juejin.cn/post/7361688292351606811

特型（trait）是 Rust 体系中的接口或抽象基类（即提供特型定义，包括入参、返回等，然后在其定一下进行功能实现，最终在代码中被使用）。
写入字节的特型称为 std::io::Write，它在标准库中的定义开头部分是这样的：

```rust
trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()> { ... }
    ...
}

```

File 和 TcpStream 这两个标准类型以及 Vec<u8> 都实现了 std::io::Write。 
&mut dyn Wtire 可以表示实现了 Write 特型的任意值的可变引用。

## 使用特型

特型表示一种能力，即一个类型可以做什么。下面是一些标准库特型：

* std::io::Write 可以用来写一些字节；
* std::iter::Iterator 可以生成一系列值；
* std::clone::Clone 能在内存中克隆自身；
* std::fmt::Debug 能用带有 {:?} 格式说明符的 println!() 进行打印。

特型有一个值得注意的规则：特型本身必须在作用域内。 否则，它的所有方法都是不可见的。
Clone 和 Iterator 的各个方法在不导入的情况下也能使用，因为默认情况下它们始终在作用域中：它们是标准库预导入的一部分，Rust 会把这些名称自动导入每个模块中。

## 特型对象

* 特型类型：dyn Write 可以表示任何实习了 Write 特型的对象，叫做特型类型
* 特型对象：对特型类型的引用叫做特型对象 &mut dyn Write


特型对象的与众不同之处在于，Rust 通常无法在编译期间知道引用目标的类型。
因此，特型对象要包含一些关于引用目标类型的额外信息。 这仅供 Rust 自己使用：当你调用 writer.write(data) 时，Rust 需要使用类型信息来根据 *writer 的具体类型动态调用正确的 write 方法。


## 泛型函数与类型参数

下面有一个函数 say_hello。使用了特性对象作为参数 out 的类型，表示任何实现了 Write 特型的类型。

```rust
use std::io::Write;

fn say_hello(out: &mut dyn Write) -> std::io::Result<()> {
	out.write_all(b"Hello world\n")?;
	out.flush()
}

```
可以变化为等价的泛型函数 `<W: Write>` 就是类型参数，这个短语叫做 类型参数。代表实现了 Write 特型的类型

```rust
fn say_hello<W: Write>(out: &mut W) -> std::io::Result<()> {
	out.write_all(b"hello world\n")?;
	out.flush()
}
```

如果需要限定满足多个特型，需要使用 + 号语法。

```rust
use std::hash::Hash;
use std::fmt::Debug;

fn top_ten<T: Debug + Hash + Eq>(values: &Vec<T>) { ... }
```

同样的，泛型也可以有多个类型参数

```rust
fn run_query<M: Mapper + Serialize, R: Reducer + Serialize>(data: &DataSet, map: M, reduce: R) {
	...
}
```
如果参数有多个直接写限定使代码不易阅读，可以使用 where 来进行参数限定。上面的例子可使用 where 关键字进行改写。

```rust
fn run_query<M, R>(data: &Dataset, map: M, reduce: R) -> Results
where M: Mapper + Seralize,
	  R: Reducer + Serialize
{
	...
}

```

如果有生命周期参数的时候,**生命周期参数在第一位**。 泛型函数也可接受常量参数。

```rust
fn dot_product<const N: usize>(a: [f64; N], b: [f64; N]) -> f64 {
	let mut sum = 0.;
	for i in 0..N {
		sum += a[i] * b[i];
	}
	sum
}

```

### 两者如何选择？
特型对象和泛型代码都基于特型，两者的选择相当微妙。
当需要混合类型值的集合时，特型对象是正确的选择。使用特型对象的另一个原因可能是想减少编译后代码的总大小。
但是，相比特型对象，泛型具有 3 个优势，在 Rust 中更常见。

* 速度快。泛型函数需要在编译期指定类型。
* 并不是每个特型都支持特型对象。
* 使用泛型函数容易同时制定具有多个特型的泛型参数限界。

## 定义与实现特型

使用 trait 关键字定义特型。提供一个名字，并列出特型方法的类型签名即可。

```rust
trait Visible {
	fn draw(&self, canvas: &mut Canvas);
	fn hit_test(&self, x: i32, y: i32) -> bool;
}
```

实现特型

```rust
impl Visible for Broom {
	fn draw(&self, canvas: &mut Canvas) {
        for y in self.y - self.height - 1 .. self.y {
            canvas.write_at(self.x, y, '|');
        }
        canvas.write_at(self.x, self.y, 'M');
    }

    fn hit_test(&self, x: i32, y: i32) -> bool {
        self.x == x
        && self.y - self.height - 1 <= y
        && y <= self.y
    }
}

```
### 特型与其他类型

Rust 允许在任意类型上实现任意特型，但特型或类型两者必须至少有一个是在当前 crate 中新建的。 意味着任何时候如果想为任意类型添加一个方法，可以使用特型来完成。

```rust
trait IsEmoji {
	fn is_emoji(&self) -> bool;
}
impl IsEmoji for char {
	fn is_emoji(&self) -> bool {
		...
	}
}

```
这个特型的唯一目的就是为类型 char 添加一个方法，称为**扩展特型**。 可使用一个泛型的 impl 块来一次性向整个类型家族添加扩展特型。

### 类型关联函数

特型可以包含类型关联函数，这是 Rust 对静态方法的模拟：

```rust
trait StringSet {
	fn new() -> Self;
	fn from_slice(strings: &[&str]) -> Self;
	fn contains(&self, string: &str) -> bool;
	fn add(&mut self, string: &str);
}

```
但是特型对象不支持类型关联函数。如果想使用 &dyn StringSet 特型对象，就必须修改此特型，为每个未通过引用接受 self 参数的关联函数加上限界 where Self: Sized。

```rust
trait StringSet {
	fn new() -> Self where Self: Sized;
	fn from_slice(strings: &[&str]) -> Self where Self: Sized;
	fn contains(&self, string: &str) -> bool;
	fn add(&mut self, string: &str);
}

```