# Rust 所有权

对于内存管理，都会希望编程语言具备两个特点：

* 内存能在选定的时机及时释放，这样能控制内存的消耗；
* 对象释放之后，绝不再使用指向它的指针；因为这种行为是未定义行为，会导致崩溃和安全漏洞。

但是两种情景很难兼顾，主流的编程语言都只能二选一。

* "安全优先" 阵营会选择垃圾回收机制来管理内存，在所有执向对象的可达指针都消失了，自动释放内存。例如 Python、JavaScirpt、Ruby、Java 等。这种情况放弃了对释放对象时机的精准控制。
* "控制优先" 阵营会让程序员自己释放内存。例如 C 和 C++ 语言。

Rust 的目标是既安全又高效。使用了独特的所有权机制。

## 所有权
在 Rust 中所有权的概念内置在语言本身，通过**编译期检查强制执行**。
**每一个值都有决定其生命周期的唯一拥有者。当拥有者被释放时，它拥有的值也会被释放**。
所有权规则：

* Rust 中每个值都有一个拥有者。
* 值在任何时刻有且仅有一个拥有者。
* 当拥有者离开作用域时，这个值将被丢弃。

## 变量作用域

**作用域**是一个变量在程序中能有效使用的范围。一个 {} 块就定义了一个作用域范围。

```rust
{
                        // s 在这里无效，尚未声明
    let s = "hello";    // 从此开始，s 有效

    // {} 范围内使用
} 			     // 超出作用域, s 被丢弃，不再有效
```

## 移动 - move

在 Rust 中，对大多数类型来说，**为变量赋值、将其传给函数或从函数中返回等操作都不会复制值，而是移动值。源变量会将值的所有权转移给目标并变为未初始化状态，改由目标来控制该值的生命周期**,
（即变量赋值、参数传递，并不是值的赋值，而是所有权的转移），
Rust 中如何处理呢？大多数类型会将值所有权从源转移到目标，而源会变为未初始化状态。这样既开销低，同时所有权也是明确的。
但是如果要同时访问这两个变量的话，需要进行深拷贝。 如果将一个值转移给已初始化的变量，那么 Rust 就会丢弃该变量先前的值

```rust
let mut s = "hello".to_string();
s = "world".to_string(); // 丢弃了值 "hello"

```

比较下面的代码：

```rust
let mut s = "hello".to_string(); // s 是一个拥有 "hello" 的 String
let t = s; // 所有权从 s 移动到 t
// Rust 的所有权规则规定，s 不再拥有这个字符串，也就是说，s 变成了未初始化状态。
// 如果在这一行代码后访问 s，编译器会报错，因为 s 的所有权已经被移动，s 不再有效。
s = "world".to_string(); // 给 s 赋值为 "world"
// 由于 s 在此之前已经不再拥有任何值，它处于未初始化状态，
// 因此这次赋值不会丢弃任何值，也不会引发内存泄漏问题。

```
* 初始化；
* 赋值；
* 从函数返回；
* 构造出新值；例如，为结构体的某个字段使用 to_string返回值初始化。该结构体拥有这个字符串的所有权。
* 将值传递给函数。

## Copy 类型：移动的例外情况

对于简单类型，例如整数、字符等，赋值的时候会直接进行拷贝操作，而不是移动。
这些类型被 Rust 指定为 Copy 类型。
标准的 Copy 类型包括所有机器整数类型、浮点数类型、char 类型、bool 类型等。Copy 类型组成的元组或固定大小的数组本身也是 Copy 类型。
默认下，Struct 类型和 enum 类型不是 Copy 类型。但是如果结构体的所有字段本身都是 Copy 类型的，可以通过 #[derive(Copy, Clone)] 来声明这个自定义的结构体为 Copy 类型。
